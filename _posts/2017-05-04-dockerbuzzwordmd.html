---
layout: post
title: Docker…Buzzword o nuovo strumento nella nostra cassetta degli utensili?
date: '2017-05-04T23:57:00.001+02:00'
author: Maurizio Attanasi
tags:
- Virtual Machines
- Docker
- Joomla!
- Ambienti di sviluppo
modified_time: '2017-05-05T09:15:15.146+02:00'
blogger_id: tag:blogger.com,1999:blog-2699321970282050013.post-1046459189367148778
blogger_orig_url: https://maurizioattanasi.blogspot.com/2017/05/dockerbuzzwordmd.html
---

Tutti quelli che come me sono sempre incuriositi alle novità si sono sicuramente imbattuti in un articolo che, a dir poco, osanna le virtù derivanti dall’utilizzo dei container per lo sviluppo e la distribuzione del software. La tecnologia dei container non è nuova. Disponibile in ambiente linux dalla versione 2.6.4 (intorno al 2004) la tecnologia nota con l’acronimo LXC, sta venendo alla ribalta negli ultimi anni grazie soprattutto alla piattaforma Docker. <br /><img alt="Docker" src="https://drive.google.com/uc?id=0BzugrVNPI3_rWDgzVzhkQk9ndjQ" title="" /> <br />Volendo semplificare all’estremo il concetto si può pensare che la containerizzazione avrà un’impatto in ambito ITC pari almeno a quello avuto dall’introduzione delle macchine virtuali.  <br /><h2 id="in-origine-erano-le-virtual-machines">In origine erano le Virtual Machines…</h2>Nella mia esperienza l’introduzione tra i miei strumenti del <a href="http://www.vmware.com/products/player/playerpro-evaluation.html">VMWare Player</a> ha portato una piccola rivoluzione nel mio modo di lavorare. All’epoca ero impegnato nello sviluppo di un sistema di visione artificiale integrato nel sistema di controllo di un robot. Il sistema di controllo era implementato su una piattaforma Linux Debian, il che mi obbligava ad avere lo stesso sistema operativo sulla macchina di sviluppo e quindi o avere due computer o, più realisticamente, installare un secondo sistema operativo ed avviare il computer a seconda del progetto al quale stavo lavorando. La possibilità di avere una macchina virtuale che mi consentiva di avere contemporanemante sotto mano sia <a href="https://www.kdevelop.org/">KDevelop</a> e <a href="https://www.debian.org/index.it.html">Debian</a> che <a href="https://www.visualstudio.com/">Visual Studio</a> e Windows Xp era il massimo in termini di comodità ed efficienza. <br />Un altro vantaggio derivante dall’utilizzo delle macchine virtuali, è stato quello di poter creare delle macchine di sviluppo molto simili, se non identiche, alle macchine in produzione in termini di pacchetti software installati, versioni particolari di driver di periferica, ecc.. Macchine di sviluppo che, in quanto virtualizzate ho la possibilità mettere da parte al termine della fase di sviluppo e tirar fuori al bisogno nel caso di un aggiornamento, di un bug fix, o di una semplice assistenza. <br /><em>Last but not Least</em> ora sono in grado di lavorare con qualunque sistema operativo a prescindere da quello installato sull’host (negli ultimi anni macOS su un Macbook Pro). <br />Il problema di fondo legato all’utilizzo delle macchine virtuali è dato dal peso che ognuna di esse ha in termini di risorse hardware cosa molto evidente se poi parliamo di un laptop. Avere a disposizione più macchine virtuale, o, peggio ancora, mandarne in esecuzione più di una allo stesso momento è un impresa ardua se si dispone di ‘soli’ 16GB di RAM ed un disco SSD da 256GB. E se poi volessimo creare un sistema di sviluppo per SharePoint? IMPOSSIBILE!…o No…? <br /><h2 id="e-poi-arrivò-docker">… E poi arrivò Docker™</h2>A rendere ancora più interessante la faccenda c’è la comunità di utenti pronti a condividere le proprie esperienze su piattaforme come <a href="https://hub.docker.com/">Docker Hub</a>. <br />Ok, di documentazione e di tutorial on line ce ne sono un’infinità ed in continuo aggironamento, quindi mi asterrò dal ripetere ci che è egregiamente illustrato da persone più esperte di me nel settore. Un buon punto di partenza è la documentazione ufficiale (<a href="https://blog.docker.com/2016/05/docker-101-getting-to-know-docker/">DOCKER 101: GETTING TO KNOW DOCKER</a>).  <br /><h2 id="un-caso-pratico">Un caso pratico</h2>Un esempio per dare un’idea della semplicità e dell’efficacia dello strumento però è il caso di farlo se non altro per invogliare qualcun altro ad approfondire l’argomento. A tal fine utilizzerò proprio un’esperienza che ho fatto poco tempo fà, per risolvere un problema ad un cliente il cui sito web, a seguito di un attacco informatico, era stato accidentalmente cancellato, e l’ultimo backup disponibile era molto differente nei contenuti dalla versione persa. Il CMS utilizzato per creare il sito era <a href="https://www.joomla.org/">Joomla!</a> nella versione 2.5, ed il database era <a href="https://www.oracle.com/it/mysql/index.html">MySql</a>. La procedura standard per predisporre un ambiente di sviluppo (LAMP, MAMP o WAMP a seconda del sistema operativo) sarebbe, in linea di principio: <br />- predisporre un server <a href="https://httpd.apache.org/">Apache</a> o <a href="https://nginx.org/en/">nginx</a>; <br />- installare la versione corretta di <a href="http://php.net/">php</a>; <br />- installare la versione corretta di MySql;  <br />In alternativa possiamo installare la versione di <a href="https://sourceforge.net/projects/wampserver/">WAMPServer</a> o <a href="https://www.mamp.info/en/">MAMP</a>.  <br /><br /><div style="text-align: center;"><img alt="WAMP" src="https://drive.google.com/uc?id=0BzugrVNPI3_rSkpiUDhTQ3d5MUU" title="" />  <img alt="MAMP" src="https://drive.google.com/uc?id=0BzugrVNPI3_rMTdvXzZGc2wwaUE" title="" />  </div><br />Qualunque strada si decida di intraprendere, al termine, il nostro pc sarà configurato per far girare un server Apache, avremo un database MySql ed una versione di php compatibile con la versione del cms del nostro sito web. Non ci resta che copiare il backup nella directory <em>htdocs</em> (o qualunque sia la cartella servita da Apache), modificare il file di configurazione in modo che possa puntare all’istanza di MySql ed al database, aprire il browser, navigare all’indirizzo <a href="http://localhost:8080/">http://localhost:8080</a> ed il gioco è fatto, abbiamo una copia del sito web che gira sulla macchina di sviluppo sulla quale fare considerazioni e/o modifiche. Fin qui la procedura classica, e per il mio caso, un intervento su un sito web in particolare può andare più che bene. In fondo, non essendo il mio mestiere, quanti siti web dovrò mai far girare sul mio laptop? Ma se così non fosse? Se arrivasse una richiesta d’intervento su un sito implementato con un cms diverso, con una diversa versione di php, o con un database diverso database? E questo sempre rimanendo nell’area dei cms che girano su server Apache, Php e MySql. Cosa dire poi se al posto di Apache fosse richiesto <a href="https://nginx.org/en/">nginx</a>, se al posto di <a href="https://www.oracle.com/it/mysql/index.html">MySql</a> avessimo bisogno di <a href="https://www.postgresql.org/">PostgreSQL</a> o <a href="https://www.microsoft.com/it-it/sql-server/sql-server-2016">SQL Server</a>, ed al posto di php volessimo <a href="http://rubyonrails.org/">Ruby on Rails</a>, o <a href="https://www.microsoft.com/net">.NET</a> o <a href="https://www.java.com/it/">Java</a>, o <a href="https://www.python.org/">python</a> o <a href="https://nodejs.org/">nodejs</a>. E via dicendo verso <em>l’infinito ed oltre</em>…. Ok possiamo installare tutto (o almeno provarci) sulla nostra macchina e tentare di creare un ambiente di sviluppo simile, per quanto possibile, all’ambiente di produzione…. <strong>SIMILE</strong> ma certamente <strong>NON UGUALE</strong>. E anche se ci accontentiamo di <strong>SIMILE</strong> dobbiamo sempre sperare che nessuno dei pacchetti installati vada in conflitto con qualcos’altro…. Ok, proviamo un’altra strada. <br />Torniamo al caso di partenza, ovvero <strong>Joomla!</strong> in una particolare versione. <br />Una possibilità è quella di creare il nostro container a partire da una versione <em>vanilla</em> di una distribuzione di Linux, e, seguendo il manuale per la creazione di un container custom, installare tutti i componenti di cui abbiamo bisogno. Oppure possiamo ricorrere alle risorse messe a disposizione da altri sviluppatori su repositories come il già citato <a href="https://hub.docker.com/">Docker Hub</a>. Facendo una ricerca con la parola chiave <em>Joomla</em> troviamo ben 158 risultati, cercando, invece <em>mysql</em>, di risultati ne abbiamo 6418!  <br /><br /><div style="text-align: center;"><img alt="docker-hub-joomla" src="https://drive.google.com/uc?id=0BzugrVNPI3_rRUxGYm5PbndCUTA" title="" />  <img alt="docker-hub-mysql" src="https://drive.google.com/uc?id=0BzugrVNPI3_rcVlpeU5FTGE4WVU" title="" />  </div><div style="text-align: center;"><br /></div>Per far girare docker sul nostro sistema di sviluppo, è sufficiente raggiungere la pagina <a href="https://www.docker.com/community-edition">Download Docker Community Edition</a>, selezionare il sistema operativo e scaricare la versione adatta al nostro sistema operativo. Ora, Docker è un sistema che gira in ambiente Linux, ma, con un piccolo accorgimento (in pratica l’installazione di una macchina virtuale) è possibile far girare Docker anche su sistemi Windows o macOS (o OsX). <br />Portata a termine l’installazione di docker torniamo su <a href="https://hub.docker.com/">Docker Hub</a>, o un altro <em>Registry</em> Docker, e scarichiamo in locale le immagini di nostro interesse lanciando da un prompt dei comandi<br /><br /><pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>docker pull joomla</code></pre><br />per scaricare l’immagine del container ufficiale di Joomla!, e  <br /><br /><pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-variable">$ </span>docker pull mysql</code></pre><br />per l’immagine di mysql.<br /><br />A questo punto abbiamo due possibilità per mandare in esecuzione i due container: <br />Il primo è quello di mandare in esecuzione i due container lanciando da un prompt dei comandi le due istruzioni opportunamente modificate (<em>per il significato dei parametri si rimanda alle pagine di <a href="https://hub.docker.com/">Docker Hub</a> dedicate ai due container</em>):<br /><pre class="prettyprint"><code class=" hljs lasso">$ docker run <span class="hljs-attribute">-it</span> <span class="hljs-subst">--</span><span class="hljs-keyword">link</span> some<span class="hljs-attribute">-mysql</span>:mysql <span class="hljs-subst">--</span>rm mysql sh <span class="hljs-attribute">-c</span> <span class="hljs-string">'exec mysql -h"$MYSQL_PORT_3306_TCP_ADDR" -P"$MYSQL_PORT_3306_TCP_PORT" -uroot -p"$MYSQL_ENV_MYSQL_ROOT_PASSWORD"'</span><br /><br />$ docker run <span class="hljs-subst">--</span>name some<span class="hljs-attribute">-joomla</span> <span class="hljs-subst">--</span><span class="hljs-keyword">link</span> some<span class="hljs-attribute">-mysql</span>:mysql <span class="hljs-attribute">-p</span> <span class="hljs-number">8080</span>:<span class="hljs-number">80</span> <span class="hljs-attribute">-d</span> joomla</code></pre>La seconda possibilità è quella di utilizzare <a href="https://docs.docker.com/compose/">Docker Compose</a> e quindi: <br />- creare una cartella dedicata al nostro progetto, all’interno della quale creeremo un file <em>YAML</em> denominato <em>docker-compose.yml</em> (il nome deve essere questo), che conterrà le seguenti istruzioni: <br /><pre class="prettyprint"><code><br />########################### <br /># Joomla! CMS Container <br />joomla: <br /># nome univoco del container <br />container_name: my_web_site<br /><br /># Definisce se il container deve essere riavviato <br />#   (i pssibili valori sono no, always e on-failure)<br />restart: always<br /><br /># Definisce l'immagine da cui avviare il container<br />image: joomla<br /><br /># Collega il container ad un altro servizio<br /># (in questo caso a quello nel quale gira l'immagine di mysql)<br />links:<br />- joomladb:mysql<br /><br /># Espone la porta, interna al container, all'esterno sulla porta 8080<br />ports:<br />- 8080:80<br /><br /># Esegue il mount di una cartella del container (/var/www/html)<br /># su una dell'host (./html)        <br />volumes:<br />- ./html/:/var/www/html        <br /># Joomla! CMS Container<br />###########################<br /><br />###########################<br /># MySql Container<br />joomladb:<br />container_name: my_web_site_db<br />restart: always<br />image: mysql<br /># Aggiunge alle variabili d'ambiente del container<br /># la password assegnata all'istanza di mysql (top of security XD)<br />environment:<br />MYSQL_ROOT_PASSWORD: root<br />ports:<br />- 3306:3306<br />volumes:<br />- ~/usr/local/var/mysql/:/var/lib/mysql<br /># MySql Container<br />###########################<br /></code></pre><br />- dalla linea di comando lanciare l’istruzione nella directory contenente il file di sopra: <br /><br /><pre class="prettyprint"><code>$ docker-compose up -d </code></pre><br />- Apriamo un browser all’indirizzo <a href="https://www.blogger.com/blogger.g?blogID=2699321970282050013#">http://127.0.0.1:8080/</a> e otterremo <br /><br /><div style="text-align: center;"><img alt="docker-joomla" height="267" src="https://drive.google.com/uc?id=0BzugrVNPI3_rZDVHeW8wdHJCRFU" title="jooml-running" width="400" /> </div><br />ed abbiamo il nostro CMS funzionante e pronto ad essere configurato per una nuova installazione. Se invece abbiamo necessità di operare localmente con il backup di un sito esistente, non ci resta che copiare il backup stesso nella cartella html, sovrascrivendo i files e le cartelle copiate dal container Joomla!, caricare sul server mysql l’ultimo backup del database, ed il gioco è fatto. <br />- quando finiamo di operare, per terminare i due container, lanciamo il comando:<br /><pre class="prettyprint"><code>$ docker-compose down</code></pre><h2 id="conclusione">Conclusione</h2>Quello illustrato è solo uno dei tanti esempi che dimostrano la semplicità con cui è possibile approntare una workstation di sviluppo per un numero enorme di tecnologie. <br />Ad oggi ho già sperimento le configurazioni ottimali per valutare diversi CMS (Wordpress, prestashop, …), con vari database (MySql, mariadb, mongodb, postgres, …), diversi server (apache, nginx, …), e via dicendo senza aver bisogno di installare niente sulla mia macchina di sviluppo e senza dover creare nuove macchine virtuali. <br />Forse la tecnologia non è ancora pronta per un utilizzo massivo in ambienti di produzione, anche se tutte le maggiori piattaforme cloud si sono attrezzate per supportare la tecnologia, ma le premesse sono ottime.<br /><br /><strong>Enjoy</strong>