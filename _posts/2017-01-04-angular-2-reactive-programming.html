---
layout: post
title: Angular 2 & Reactive Programming
date: '2017-01-04T08:00:00.000+01:00'
author: Maurizio Attanasi
tags:
- Reactive Programming
- ".NET"
- Angular 2
modified_time: '2018-03-17T18:59:21.918+01:00'
blogger_id: tag:blogger.com,1999:blog-2699321970282050013.post-4372345093555730178
blogger_orig_url: https://maurizioattanasi.blogspot.com/2017/01/angular-2-reactive-programming.html
---

<img alt="Rx" src="https://drive.google.com/uc?id=0BzugrVNPI3_rOUNESWhvVXJmOTg" title="" />    <img alt="Angular 2" src="https://drive.google.com/uc?id=0BzugrVNPI3_rMUJQQ0UteTBCaDQ" title="" /> <br />Il mio primo approccio con la <em>Programmazione Reattiva</em> (o meglio <strong>FRP</strong> - <b>F</b>unctional <b>R</b>eactive <b>P</b>rogramming) risale ormai a metà del 2013 quando, dopo aver letto una serie di articoli che descrivevano il paradigma di programmazione, ho deciso di introdurre un'implementazione di tale tecnica per .NET in una nuova release di un sistema <a href="https://it.wikipedia.org/wiki/Manufacturing_Execution_System">MES</a> (<b>M</b>anufacturing <b>E</b>xecution <b>S</b>ystem) che ho progettato ed implementato per l’azienda per cui lavoravo all’epoca. La libreria in questione era denominata <a href="http://reactivex.io/">Rx - Reactive Extensions</a>. <br /><br />In parole povere, le diverse implementazioni di <strong>Rx</strong>, consentono di manipolare flussi di dati e/o eventi (<a href="http://reactivex.io/documentation/observable.html">Observable</a>) al fine di semplificare notevolmente lo sviluppo di codice asincrono mediante una <strong>sottoscrizione</strong>, <a href="http://reactivex.io/documentation/operators/subscribe.html">Subscription</a>, alle variazioni di tali flussi.<br /><br />Tra i vari benefici che si possono avere con l’adozione di tali tecniche, quella che, a mio parere, è quella di maggior pregio, è data dal fatto che una volta creato uno stream di dati, diversi client possono effettuare una sottoscrizione alle variazioni dello stesso ottenendo, a costo zero, un sistema in grado di comunicare in modo <em>broadcast</em> con diversi client. <br /><br />Le diverse implementazioni del paradigma, comprendono anche una libreria JavaScript denominata <a href="https://github.com/Reactive-Extensions/RxJS">RxJS</a>, e viene installata tra i diversi pacchetti a corredo di <a href="https://angular.io/">Angular 2</a>. <br />Una delle applicazioni che meglio si prestano all’utilizzo della programmazione reattiva in un’applicazione Angular 2 è data dalla fruizione di un servizio REST. <br />Nei post precedenti abbiamo creato sia un’applicazione client basata su Angular 2 che una Web API sviluppata con ASP.NET Core, ed entrambe hanno trovato posto su <a href="https://portal.azure.com/">Azure</a>. <br />Riprendendo il post precedente <a href="https://maurizioattanasi.blogspot.it/2016/12/restful-api-con-swaggermd.html">RESTful API con Swagger</a>, e concentrandoci sul dettaglio della lista dei metodi esposti dal servizio, abbiamo: <br /><img alt="REST API" src="https://drive.google.com/uc?id=0BzugrVNPI3_rUm5MTXFteGswSUk" title="" /> <br />Con questi metodi, possiamo pensare alla realizzazione di un’applicazione CRUD finalizzata alla gestione di una piccola biblioteca personale. <br />I sorgenti dell’intero progetto sono disponibili per la consultazione su <a href="https://github.com/alien70/talking-things">github</a>, ed il risultato finale, è una Web Application di azure raggiungibile all’indirizzo <a href="http://talking-things.azurewebsites.net/#/library">http://talking-things.azurewebsites.net/#/library</a>. <br />Il modulo principale è dato dal componente <a href="https://github.com/alien70/talking-things/tree/master/src/app/library">library</a> che si presenta come segue: <br /><img alt="libary-main" height="258" src="https://drive.google.com/uc?id=0BzugrVNPI3_rUEhRQWx6RmVRVUE" title="" width="400" />  <br />ed la cui implementazione è data da: <br /><br /><pre class="prettyprint"><code class="language-typescript hljs coffeescript"><span class="hljs-reserved">import</span> { Component, OnInit, ViewChild } from <span class="hljs-string">'@angular/core'</span>;<br /><span class="hljs-reserved">import</span> { Subscription } from <span class="hljs-string">'rxjs/Rx'</span>;<br /><span class="hljs-reserved">import</span> { Router } from <span class="hljs-string">'@angular/router'</span>;<br /><span class="hljs-reserved">import</span> { environment } from <span class="hljs-string">'../../environments/environment'</span>;<br /><span class="hljs-reserved">import</span> { BookStoreService } from <span class="hljs-string">'../bookstore.service'</span>;<br /><span class="hljs-reserved">import</span> { Book } from <span class="hljs-string">'../models/book'</span>;<br /><span class="hljs-reserved">import</span> { ModalComponent } from <span class="hljs-string">'../modal/modal.component'</span>;<br /><br /><span class="hljs-property">@Component</span>({<br />  <span class="hljs-attribute">selector</span>: <span class="hljs-string">'app-library'</span>,<br />  <span class="hljs-attribute">templateUrl</span>: <span class="hljs-string">'./library.component.html'</span>,<br />  <span class="hljs-attribute">styleUrls</span>: [<span class="hljs-string">'./library.component.css'</span>],<br />  <span class="hljs-attribute">providers</span>: [BookStoreService]<br />})<br /><span class="hljs-reserved">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LibraryComponent</span> <span class="hljs-title">implements</span> <span class="hljs-title">OnInit</span> {</span><br /><br />  title = <span class="hljs-string">'Book Store'</span>;<br /><br />  <span class="hljs-attribute">books</span>: Book[] = [];<br /><br />  <span class="hljs-attribute">errorMessage</span>: string = <span class="hljs-string">''</span>;<br />  <span class="hljs-attribute">isLoading</span>: boolean = <span class="hljs-literal">true</span>;<br /><br />  <span class="hljs-property">@ViewChild</span>(ModalComponent) <span class="hljs-attribute">modal</span>: ModalComponent;<br /><br />  private <span class="hljs-attribute">subscription</span>: Subscription;<br />  constructor(private <span class="hljs-attribute">_router</span>: Router, private <span class="hljs-attribute">_bookStoreService</span>: BookStoreService) { }<br /><br />  ngOnInit() {<br />    <span class="hljs-keyword">this</span>.reloadData();<br />  }<br /><br />  reloadData() {<br />    <span class="hljs-keyword">this</span>._bookStoreService<br />      .GetAll()<br />      .subscribe(<br />      b<span class="hljs-function"> =&gt;</span> <span class="hljs-keyword">this</span>.books = b,<br />      e<span class="hljs-function"> =&gt;</span> <span class="hljs-keyword">this</span>.errorMessage = e,<br />      <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.isLoading = <span class="hljs-literal">false</span>);<br />  }<br /><br />  onNew() {<br />    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"onNew"</span>);<br />    <span class="hljs-keyword">this</span>._router.navigate([<span class="hljs-string">'/edit'</span>, <span class="hljs-string">'new'</span>]);<br />  }<br /><br />  onEdit(<span class="hljs-attribute">book</span>: Book) {<br />    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'edit '</span> + book.id);<br />    <span class="hljs-keyword">this</span>._router.navigate([<span class="hljs-string">'/edit'</span>, book.id]);<br />  }<br /><br />  onDelete(book) {<br /><br />    <span class="hljs-reserved">var</span> <span class="hljs-attribute">message</span>: string = <span class="hljs-string">'Delete \''</span> + book.title + <span class="hljs-string">'\'?: '</span>;<br />    <span class="hljs-keyword">this</span>.modal.Title = <span class="hljs-string">'Warning'</span>;<br />    <span class="hljs-keyword">this</span>.modal.show(message);<br />    <span class="hljs-keyword">this</span>.subscription = <span class="hljs-keyword">this</span>.modal.observable.subscribe(x<span class="hljs-function"> =&gt;</span> {<br /><br />      <span class="hljs-keyword">if</span> (x) {<br />        <span class="hljs-keyword">this</span>._bookStoreService.Delete(book.id).subscribe(<br />          book<span class="hljs-function"> =&gt;</span> {<br />            <span class="hljs-reserved">let</span> b = <span class="hljs-keyword">this</span>.books.find(item<span class="hljs-function"> =&gt;</span> item.id === book.id);<br />            <span class="hljs-reserved">let</span> id = <span class="hljs-keyword">this</span>.books.indexOf(b);<br />            <span class="hljs-keyword">this</span>.books.splice(id, <span class="hljs-number">1</span>);<br />            <span class="hljs-keyword">if</span> (!environment.production)<br />              <span class="hljs-built_in">console</span>.log(JSON.stringify(book));<br />          },<br />          error<span class="hljs-function"> =&gt;</span> {<br />            <span class="hljs-built_in">console</span>.log(error);<br />          }<br />        );<br />      }<br /><br />      <span class="hljs-keyword">this</span>.subscription.unsubscribe();<br />    });<br />  }<br />}</code></pre><pre class="prettyprint"><code class="language-typescript hljs coffeescript"><br /></code></pre>e dal servizio <a href="https://github.com/alien70/talking-things/blob/master/src/app/bookstore.service.ts">BookStoreService</a>, cuore del vero interfacciamento con il servizio REST:<br /><br /><pre class="prettyprint"><code class="language-typescript hljs cs">import { Injectable } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/core'</span>;<br />import { Http, Response, Headers } <span class="hljs-keyword">from</span> <span class="hljs-string">'@angular/http'</span>;<br />import { Observable } <span class="hljs-keyword">from</span> <span class="hljs-string">'rxjs/Rx'</span>;<br /><br />import { Book } <span class="hljs-keyword">from</span> <span class="hljs-string">'./models/book'</span>;<br /><br />import { environment } <span class="hljs-keyword">from</span> <span class="hljs-string">'../environments/environment'</span>;<br /><br />@Injectable()<br />export class BookStoreService {<br />    <span class="hljs-keyword">private</span> baseUrl: <span class="hljs-keyword">string</span>;<br /><br />    constructor(<span class="hljs-keyword">private</span> _http: Http) {<br />        <span class="hljs-keyword">this</span>.baseUrl = environment.bookStoreApi.server + environment.bookStoreApi.apiUrl + <span class="hljs-string">'/books/'</span>;<br />    }<br /><br />    GetAll(): Observable&lt;Book[]&gt; {<br /><br />        <span class="hljs-keyword">if</span> (!environment.production)<br />            console.log(<span class="hljs-keyword">this</span>.baseUrl);<br /><br />        <span class="hljs-keyword">let</span> books$ = <span class="hljs-keyword">this</span>._http.<span class="hljs-keyword">get</span>(<span class="hljs-keyword">this</span>.baseUrl, { headers: <span class="hljs-keyword">this</span>.GetHeaders() })<br />            .map(mapBooks)<br />            .<span class="hljs-keyword">catch</span>(handleError);<br /><br />        <span class="hljs-keyword">return</span> books$;<br />    }<br /><br />    <span class="hljs-keyword">public</span> GetById = (id: <span class="hljs-keyword">string</span>): Observable&lt;Book&gt; =&gt; {<br />        <span class="hljs-keyword">let</span> books$ = <span class="hljs-keyword">this</span>._http.<span class="hljs-keyword">get</span>(<span class="hljs-keyword">this</span>.baseUrl + id, { headers: <span class="hljs-keyword">this</span>.GetHeaders() })<br />            .map(response =&gt; response.json())<br />            .<span class="hljs-keyword">catch</span>(handleError);<br />        <span class="hljs-keyword">return</span> books$;<br />    }<br /><br />    <span class="hljs-keyword">public</span> Create = (book: Book): Observable&lt;any&gt; =&gt; {<br />        <span class="hljs-keyword">let</span> book$ = <span class="hljs-keyword">this</span>._http.post(<span class="hljs-keyword">this</span>.baseUrl, book, { headers: <span class="hljs-keyword">this</span>.GetHeaders() })            <br />            .<span class="hljs-keyword">catch</span>(handleError);<br /><br />        <span class="hljs-keyword">return</span> book$;<br />    }<br /><br />    <span class="hljs-keyword">public</span> Update = (id: <span class="hljs-keyword">string</span>, book: Book): Observable&lt;any&gt; =&gt; {<br />        <span class="hljs-keyword">let</span> book$ = <span class="hljs-keyword">this</span>._http.put(<span class="hljs-keyword">this</span>.baseUrl + id, book, { headers: <span class="hljs-keyword">this</span>.GetHeaders() })<br />            .<span class="hljs-keyword">catch</span>(handleError);<br /><br />        <span class="hljs-keyword">return</span> book$;<br />    }<br /><br />    <span class="hljs-keyword">public</span> Delete = (id: <span class="hljs-keyword">string</span>): Observable&lt;Book&gt; =&gt; {<br />        <span class="hljs-keyword">let</span> book$ = <span class="hljs-keyword">this</span>._http.delete(<span class="hljs-keyword">this</span>.baseUrl + id)<br />            .<span class="hljs-keyword">catch</span>(handleError);<br /><br />        <span class="hljs-keyword">return</span> book$;<br />    }<br /><br />    <span class="hljs-keyword">private</span> <span class="hljs-title">GetHeaders</span>() {<br />        <span class="hljs-keyword">let</span> headers = <span class="hljs-keyword">new</span> Headers();<br /><br />        headers.append(<span class="hljs-string">'Accept'</span>, <span class="hljs-string">'application/json'</span>);<br /><br />        <span class="hljs-keyword">return</span> headers;<br />    }<br />}<br /><br />function mapBooks(response: Response): Book[] {<br />    <span class="hljs-keyword">return</span> response.json().map(toBook);<br />}<br /><br />function toBook(r: any): Book {<br />    <span class="hljs-keyword">if</span> (!environment.production)<br />        console.log(<span class="hljs-string">'toBook: '</span> + JSON.stringify(r));<br /><br />    <span class="hljs-keyword">let</span> book = &lt;Book&gt;({<br />        id: r.id,<br />        title: r.title,<br />        authors: r.authors,<br />        publicationYear: r.publicationYear,<br />        isAvailable: r.isAvailable<br />    });<br /><br />    <span class="hljs-keyword">if</span> (!environment.production)<br />        console.log(<span class="hljs-string">'Parsed book: '</span>, book);<br /><br />    <span class="hljs-keyword">return</span> book;<br />}<br /><br />function handleError(error: Response) {<br />    <span class="hljs-keyword">return</span> Observable.<span class="hljs-keyword">throw</span>(error || <span class="hljs-string">'Server error'</span>);<br />}</code></pre><pre class="prettyprint"><code class="language-typescript hljs cs"><br /></code></pre>Per avere un’idea di come l’utilizzo della <strong>FRP</strong> abbia reso più agevole la gestione della programmazione asincrona focalizziamo la nostra attenzione sul metodo <em>GetAll()</em> che ritorna uno stream <em>Observable</em><br /><em><br /></em> <br /><pre class="prettyprint"><code class="language-typescript hljs http">    <span class="hljs-attribute">GetAll()</span>: <span class="hljs-string">Observable&lt;Book[]&gt; {</span><br /><br /><span class="cs">        <span class="hljs-keyword">if</span> (!environment.production)<br />            console.log(<span class="hljs-keyword">this</span>.baseUrl);<br /><br />        <span class="hljs-keyword">let</span> books$ = <span class="hljs-keyword">this</span>._http.<span class="hljs-keyword">get</span>(<span class="hljs-keyword">this</span>.baseUrl, { headers: <span class="hljs-keyword">this</span>.GetHeaders() })<br />            .map(mapBooks)<br />            .<span class="hljs-keyword">catch</span>(handleError);<br /><br />        <span class="hljs-keyword">return</span> books$;<br />    }</span></code></pre><br />ed al quale il componente <em>library</em> effettua una sottoscrizione mediante il metodo <em>subscribe</em>:<br /><pre class="prettyprint"><code class="language-typescript hljs coffeescript">     <span class="hljs-keyword">this</span>._bookStoreService<br />      .GetAll()<br />      .subscribe(<br />      b<span class="hljs-function"> =&gt;</span> <span class="hljs-keyword">this</span>.books = b,<br />      e<span class="hljs-function"> =&gt;</span> <span class="hljs-keyword">this</span>.errorMessage = e,<br />      <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">this</span>.isLoading = <span class="hljs-literal">false</span>);</code></pre><pre class="prettyprint"><code class="language-typescript hljs coffeescript"><br /></code></pre>In modo analogo vengono implementate le interfacce verso gli altri metodi esposti dal servizio REST. <br />Facile e pulito…<br /><br />Enjoy<br /><br /><div style="text-align: left;"><div style="display: inline-block;"><script data-counter="right" data-url="https://maurizioattanasi.blogspot.it/2017/01/angular-2-reactive-programming.html" type="IN/Share"></script><br /></div><div class="g-plusone" data-annotation="inline" data-width="300" style="display: inline-block;"></div></div>